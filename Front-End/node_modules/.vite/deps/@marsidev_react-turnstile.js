"use client";
import {
  require_jsx_runtime
} from "./chunk-S725DACQ.js";
import {
  require_react
} from "./chunk-RLJ2RCJQ.js";
import {
  __toESM
} from "./chunk-DC5AMYBS.js";

// node_modules/@marsidev/react-turnstile/dist/index.js
var import_react = __toESM(require_react());
var import_react2 = __toESM(require_react());
var import_jsx_runtime = __toESM(require_jsx_runtime());
var import_react3 = __toESM(require_react());
var import_jsx_runtime2 = __toESM(require_jsx_runtime());
var ue = ({ as: n = "div", ...a }, s) => (0, import_jsx_runtime.jsx)(n, { ...a, ref: s });
var J = (0, import_react2.forwardRef)(ue);
var K = "https://challenges.cloudflare.com/turnstile/v0/api.js";
var I = "cf-turnstile-script";
var z = "cf-turnstile";
var _ = "onloadTurnstileCallback";
var W = (n) => !!document.getElementById(n);
var X = ({ render: n = "explicit", onLoadCallbackName: a = _, scriptOptions: { nonce: s = "", defer: e = true, async: m = true, id: S = "", appendTo: g, onError: T, crossOrigin: w = "" } = {} }) => {
  let E = S || I;
  if (W(E)) return;
  let i = document.createElement("script");
  if (i.id = E, i.src = `${K}?onload=${a}&render=${n}`, document.querySelector(`script[src="${i.src}"]`)) return;
  i.defer = !!e, i.async = !!m, s && (i.nonce = s), w && (i.crossOrigin = w), T && (i.onerror = T, delete window[a]), (g === "body" ? document.body : document.getElementsByTagName("head")[0]).appendChild(i);
};
var f = { normal: { width: 300, height: 65 }, compact: { width: 150, height: 140 }, invisible: { width: 0, height: 0, overflow: "hidden" }, flexible: { minWidth: 300, width: "100%", height: 65 }, interactionOnly: { width: "fit-content", height: "auto", display: "flex" } };
function G(n) {
  if (n !== "invisible" && n !== "interactionOnly") return n;
}
function $(n = I) {
  let [a, s] = (0, import_react3.useState)(false);
  return (0, import_react3.useEffect)(() => {
    let e = () => {
      W(n) && s(true);
    }, m = new MutationObserver(e);
    return m.observe(document, { childList: true, subtree: true }), e(), () => {
      m.disconnect();
    };
  }, [n]), a;
}
var k = "unloaded";
var te;
var we = new Promise((n, a) => {
  te = { resolve: n, reject: a }, k === "ready" && n(void 0);
});
var ee = (n = _) => (k === "unloaded" && (k = "loading", window[n] = () => {
  te.resolve(), k = "ready", delete window[n];
}), we);
var Ee = (0, import_react.forwardRef)((n, a) => {
  let { scriptOptions: s, options: e = {}, siteKey: m, onWidgetLoad: S, onSuccess: g, onExpire: T, onError: w, onBeforeInteractive: E, onAfterInteractive: i, onUnsupported: b, onTimeout: A, onLoadScript: j, id: re, style: ne, as: oe = "div", injectScript: B = true, rerenderOnCallbackChange: o = false, ...ie } = n, c = e.size, H = (0, import_react.useCallback)(() => typeof c > "u" ? {} : e.execution === "execute" ? f.invisible : e.appearance === "interaction-only" ? f.interactionOnly : f[c], [e.execution, c, e.appearance]), [se, R] = (0, import_react.useState)(H()), u = (0, import_react.useRef)(null), [x, F] = (0, import_react.useState)(false), r = (0, import_react.useRef)(void 0), L = (0, import_react.useRef)(false), V = re || z, d = (0, import_react.useRef)({ onSuccess: g, onError: w, onExpire: T, onBeforeInteractive: E, onAfterInteractive: i, onUnsupported: b, onTimeout: A });
  (0, import_react.useEffect)(() => {
    o || (d.current = { onSuccess: g, onError: w, onExpire: T, onBeforeInteractive: E, onAfterInteractive: i, onUnsupported: b, onTimeout: A });
  });
  let N = (s == null ? void 0 : s.id) || I, D = $(N), C = (s == null ? void 0 : s.onLoadCallbackName) || _, ce = e.appearance || "always", P = (0, import_react.useMemo)(() => ({ sitekey: m, action: e.action, cData: e.cData, theme: e.theme || "auto", language: e.language || "auto", tabindex: e.tabIndex, "response-field": e.responseField, "response-field-name": e.responseFieldName, size: G(c), retry: e.retry || "auto", "retry-interval": e.retryInterval || 8e3, "refresh-expired": e.refreshExpired || "auto", "refresh-timeout": e.refreshTimeout || "auto", execution: e.execution || "render", appearance: e.appearance || "always", "feedback-enabled": e.feedbackEnabled ?? true, callback: (t) => {
    var _a, _b;
    L.current = true, o ? g == null ? void 0 : g(t) : (_b = (_a = d.current).onSuccess) == null ? void 0 : _b.call(_a, t);
  }, "error-callback": o ? w : (...t) => {
    var _a, _b;
    return (_b = (_a = d.current).onError) == null ? void 0 : _b.call(_a, ...t);
  }, "expired-callback": o ? T : (...t) => {
    var _a, _b;
    return (_b = (_a = d.current).onExpire) == null ? void 0 : _b.call(_a, ...t);
  }, "before-interactive-callback": o ? E : (...t) => {
    var _a, _b;
    return (_b = (_a = d.current).onBeforeInteractive) == null ? void 0 : _b.call(_a, ...t);
  }, "after-interactive-callback": o ? i : (...t) => {
    var _a, _b;
    return (_b = (_a = d.current).onAfterInteractive) == null ? void 0 : _b.call(_a, ...t);
  }, "unsupported-callback": o ? b : (...t) => {
    var _a, _b;
    return (_b = (_a = d.current).onUnsupported) == null ? void 0 : _b.call(_a, ...t);
  }, "timeout-callback": o ? A : (...t) => {
    var _a, _b;
    return (_b = (_a = d.current).onTimeout) == null ? void 0 : _b.call(_a, ...t);
  } }), [e.action, e.appearance, e.cData, e.execution, e.language, e.refreshExpired, e.responseField, e.responseFieldName, e.retry, e.retryInterval, e.tabIndex, e.theme, e.feedbackEnabled, e.refreshTimeout, m, c, o, o ? g : null, o ? w : null, o ? T : null, o ? E : null, o ? i : null, o ? b : null, o ? A : null]), y = (0, import_react.useCallback)(() => typeof window < "u" && !!window.turnstile, []);
  return (0, import_react.useEffect)(function() {
    B && !x && (ee(C), X({ onLoadCallbackName: C, scriptOptions: { ...s, id: N } }));
  }, [B, x, s, N, C]), (0, import_react.useEffect)(function() {
    k !== "ready" && ee(C).then(() => F(true)).catch(console.error);
  }, [C]), (0, import_react.useEffect)(function() {
    if (!u.current || !x) return;
    let l = false;
    return (async () => {
      if (l || !u.current) return;
      let U = window.turnstile.render(u.current, P);
      r.current = U, r.current && (S == null ? void 0 : S(r.current));
    })(), () => {
      l = true, r.current && (window.turnstile.remove(r.current), L.current = false);
    };
  }, [V, x, P]), (0, import_react.useImperativeHandle)(a, () => {
    let { turnstile: t } = window;
    return { getResponse() {
      if (!(t == null ? void 0 : t.getResponse) || !r.current || !y()) {
        console.warn("Turnstile has not been loaded");
        return;
      }
      return t.getResponse(r.current);
    }, async getResponsePromise(l = 3e4, Y = 100) {
      return new Promise((U, M) => {
        let p, q = async () => {
          if (L.current && window.turnstile && r.current) try {
            let v = window.turnstile.getResponse(r.current);
            return p && clearTimeout(p), v ? U(v) : M(new Error("No response received"));
          } catch (v) {
            return p && clearTimeout(p), console.warn("Failed to get response", v), M(new Error("Failed to get response"));
          }
          p || (p = setTimeout(() => {
            p && clearTimeout(p), M(new Error("Timeout"));
          }, l)), await new Promise((v) => setTimeout(v, Y)), await q();
        };
        q();
      });
    }, reset() {
      if (!(t == null ? void 0 : t.reset) || !r.current || !y()) {
        console.warn("Turnstile has not been loaded");
        return;
      }
      e.execution === "execute" && R(f.invisible);
      try {
        L.current = false, t.reset(r.current);
      } catch (l) {
        console.warn(`Failed to reset Turnstile widget ${r}`, l);
      }
    }, remove() {
      if (!(t == null ? void 0 : t.remove) || !r.current || !y()) {
        console.warn("Turnstile has not been loaded");
        return;
      }
      R(f.invisible), L.current = false, t.remove(r.current), r.current = null;
    }, render() {
      if (!(t == null ? void 0 : t.render) || !u.current || !y() || r.current) {
        console.warn("Turnstile has not been loaded or container not found");
        return;
      }
      let l = t.render(u.current, P);
      return r.current = l, r.current && (S == null ? void 0 : S(r.current)), e.execution !== "execute" && R(c ? f[c] : {}), l;
    }, execute() {
      if (e.execution !== "execute") {
        console.warn('Execution mode is not set to "execute"');
        return;
      }
      if (!(t == null ? void 0 : t.execute) || !u.current || !r.current || !y()) {
        console.warn("Turnstile has not been loaded or container not found");
        return;
      }
      t.execute(u.current, P), R(c ? f[c] : {});
    }, isExpired() {
      return !(t == null ? void 0 : t.isExpired) || !r.current || !y() ? (console.warn("Turnstile has not been loaded"), false) : t.isExpired(r.current);
    } };
  }, [r, e.execution, c, P, u, y, x, S]), (0, import_react.useEffect)(() => {
    if (x || !D) return;
    if (window.turnstile) {
      F(true);
      return;
    }
    let t = setInterval(() => {
      window.turnstile && (F(true), clearInterval(t));
    }, 50);
    return () => {
      clearInterval(t);
    };
  }, [x, D]), (0, import_react.useEffect)(() => {
    R(H());
  }, [e.execution, c, ce]), (0, import_react.useEffect)(() => {
    !D || typeof j != "function" || j();
  }, [D]), (0, import_jsx_runtime2.jsx)(J, { ref: u, as: oe, id: V, style: { ...se, ...ne }, ...ie });
});
Ee.displayName = "Turnstile";
export {
  z as DEFAULT_CONTAINER_ID,
  _ as DEFAULT_ONLOAD_NAME,
  I as DEFAULT_SCRIPT_ID,
  K as SCRIPT_URL,
  Ee as Turnstile
};
//# sourceMappingURL=@marsidev_react-turnstile.js.map
